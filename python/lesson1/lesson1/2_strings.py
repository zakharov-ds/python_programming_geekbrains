# =================================
#             Строки
# =================================

s = 'Hello'
s2 = "world"
print(s, s2)

s3 = '''Lorem ipsum 
dolor sit amet'''
s4 = """Lorem
ipsum
dolor..."""
print(s3, s4)

s5 = "Lorem\nipsum\ndolor..."
print(s5)
print( s4 == s5)

s6 = r"Lorem\nipsum\ndolor..." # "сырая" строка, спецсимволы \n не будут конвертироваться в новые строки
print(s6)

# Строки можно складывать:
print('Hello' + ' ' + 'world')
# Если строки идут друг за другом, + можно опустить (конкатенация строк прозойдет автоматически):
print('Hello'  ' '  'world')
# Строки повторять операцией *:
print('Hey! ' * 3)

# Строки могут быть проиндексированы. Первый симпол, как в C имеет индекс 0:
print(s[1])

# Срезы
# Подстроку можно получить при помощи срезов:
print(s3[6:11])

# Значения по умолчанию: опущенный первый индекс заменяется нулём, опущенный второй индекс подменяется размером срезаемой строки.
print(s3[6:])
print(s3[:11])

# s6[3] = 'g' # такая конструкция вызовет ошибку, так как строки — неизменяемый объект

# Чересчур большой индекс заменяется на размер строки:
print(s3[6:100])

# Верхняя граница меньшая нижней возвращает пустую строку:
print(s3[50:])
print(s3[6:1])

# Индексы могут быть отрицательными числами, обозначая при этом отсчет справа налево:
print(s3[-1])     # Последний символ
print(s3[-2])     # Предпоследний символ
print(s3[-2:])    # Последние два символа
print(s3[:-2])    # Всё, кроме последних двух символов

# Хороший способ понять, как работают срезы - думать о них, как об указателях на места между символами:
#  +---+---+---+---+---+
#  | L | o | r | e | m |
#  +---+---+---+---+---+
#  0   1   2   3   4   5
# -5  -4  -3  -2  -1

# Длина строки:
print(len(s))
